\chapter{Communication Paradigms for MANETs}\label{chapter:paradigms}

This dissertation is mainly an investigation into patterns of communication used in applications operating in a MANET environment. These communication patterns largely fall into categories of communication paradigms - approaches to abstracting the interactions between distributed nodes. In this chapter, we first examine the characteristics of MANETs and the desired features of communication paradigms in Section \ref{characters}, then provide an overview of various paradigms in Section \ref{paradigms}.

\section{Mobile Ad Hoc Network Characteristics}\label{characters}

Mobile ad hoc networks (MANETs) are composed of mobile nodes which may join or leave the network at any point. These nodes are typically small and battery-powered, such as smartphones, smart watches, PDAs, tablets, netbooks, or laptops. MANETs are not limited to such small nodes, however. They can include unmanned aerial vehicles (UAVs), passenger vehicles, buses, commercial trucks, and any other kind of mobile device. Typically, though, MANETs are expected to consist mostly of devices with limited battery, processing power, memory, and storage.

Besides being mobile, the other main characteristic of MANETs is their communication via an infrastructureless wireless network. In other words, nodes wirelessly communicate directly with each other or by using other nodes to relay messages. The networks are entirely self-organizing and, in the most general case, rely on no access points, cellular towers, or any other type of fixed wireless receiver.

Mobility and wireless are at the root of all of the challenges MANET applications face. The network topology can change rapidly with nodes joining and leaving at any time without warning, leading to lost information and broken network routes. Wireless communication can be disrupted in many ways, including competing broadcasts, physical obstacles, and nodal mobility.

\section{Requirements}\label{sec:manetrecs}

Based on the characteristics of MANETs, we have identified three key challenges when creating applications to operate in MANETs.

\subsection{Disconnection Handling}

Due to the unreliability of wireless communication and the ability of nodes to physically move, applications in MANETs can experience frequent disconnections. Unlike traditional distributed computing, which typically views disconnections as exceptional events and errors, applications in MANETs must be able to handle disconnections as part of their normal operation.

In a MANET, nodes are highly mobile and disconnections occur frequently, either due to channel condition variation or the mobility of destinations and intermediate nodes. Disconnections may be prolonged, brief, or intermittent and applications must handle all three. Traditional networking treats disconnections as failures, but a programming environment for MANETs needs to handle disconnections as a natural element of the environment.

Besides simply hiding disconnections, the decentralized nature of MANETs causes difficulties for any operations which require global state, a global view of the network, or long-term coordination among nodes. Communication paradigms and their implementations must be able to operate in a distributed manner.

\subsection{Addressing and Discovery}

The lack of infrastructure in a MANET requires a decentralized method for finding and addressing resources. Traditional approaches such as DNS cannot be maintained in a MANET, so alternative means of discovering and addressing resources must be provided. The spontaneous nature of MANETs also dictates that discovery be dynamic, as the network topology cannot be known ahead of time and may change rapidly.

Unlike a wired network with a fixed infrastructure, MANETs cannot depend on centralized look up services like DNS to find peers. Since devices are constantly joining and leaving the network and it is not possible to maintain IP addresses or URLs to locate resources, applications must be able to locate them dynamically.

Addressing resources may be accomplished at different levels of abstraction. Addresses relying on MAC or IP addresses would be too fragile in a MANET. Instead, it is preferable to be able to refer to a resource by either a name or a value describing its contents or function. This allows the resource to be addresses independent of its actual location or even implementation. For example, an application may wish to print a document, so it would send print job to a printer resource. The actual printer which is used may vary over time and location, but the application only requires that it be able to print the document.

\subsection{Flexible Communication}

Basic communication between devices in a wired network is generally accomplished in a one-to-one unicast manner. In a MANET, multicast communication is also common due to the broadcast nature of wireless networking and bandwidth limitations. Collaborative applications, networked games, and streaming media also benefit from group communication. Providing flexible communication is crucial to developing applications for MANETs.

Besides unicast and multicast communication, it is also desirable to support \textit{private} unicast communication between nodes, in the sense that nodes cannot eavesdrop on or disrupt each other's communication within the communication paradigm. Many mobile applications provide private one-on-one communication, such as instant messages, SMS, direct messages on social networks, email, and other confidential communication.

A general purpose communication paradigm should provide easy access to all kinds of communication patterns.

\section{Communication Paradigms}\label{paradigms}

Work in this area has mostly focused on adapting existing distributed computing paradigms to the mobile ad hoc environment, as we will discuss in this section.

It is useful to describe communication paradigms in terms of temporal and referential coupling~\cite{distbook}. When a paradigm is temporally coupled, it requires the sender and the receiver to both be present for a message to be sent. If it is temporally decoupled, a message can be stored at sending time and then delivered when the receiver becomes available. Referential coupling indicates whether or not the sender and receiver need to be directly aware of each other. A referentially coupled system explicitly addresses receivers, while a referentially decoupled system does not need to know with which nodes it is communicating (e.g. IP addresses), it operates at a higher level of abstraction.

Both temporal and referential decoupling are preferred in a MANET. If a paradigm is temporally decoupled, it is more likely to be able to handle disconnections and changing network topologies. Referential decoupling is useful, because it avoids the need for a centralized naming system and allows remote resources to be addressed using application-level semantics, rather than having to drop down to the network layer. This also allows resources to logically move between physical hosts without changing the address used by the application.

A third type of coupling, synchronization, is mentioned in \cite{psfaces}. If a paradigm implements synchronization decoupling, then the message sender is not blocked when sending a message, and a receiver does not block when waiting for a message. In other words, sending and receiving of messages occurs outside the main thread of the application. Typically this means sending a message returns immediately and received messages are handled asynchronously in a callback method.

\subsection{Publish/Subscribe}

The \textit{publish/subscribe} paradigm divides processes into publishers and subscribers. In topic-based publish/subscribe, publishers broadcast messages tagged with one or more topics. Subscribers receive the messages by subscribing to one or more topics and specifying a callback to receive the publications asynchronously and separately from the main process thread. Publish/subscribe does not guarantee any ordering of publications nor does it specify how to deliver messages if the subscribers is not available at the time of publication. Publish/subscribe is temporally, referentially, and synchronization decoupled. Messages may be sent and received at any time, and it is possible to handle multiple incoming publications concurrently.

Publish/subscribe is completely oriented towards group communication. The only method of communication is publishing a message to a topic. There may be zero or more subscribers to that topic, all of which will receive the message, provided the subscribers are available. One-to-one communication can only be achieved by coordination at the application layer. For example, two nodes may agree to communicate via a topic which they assume no one else will use.

Topic-based publish/subscribe is the simplest variation for subscriptions. Subscriptions may be based on hierarchical topics or tags, content of the messages, type structures, and so on.

Typically, there is a system of fixed nodes which serve as \textit{brokers} which manage subscriber lists and delivery of messages. However, the brokering system is completely transparent to the application layer, which is only able to subscribe to topics and publish messages. This maintains the referential decoupling that publish/subscribe systems provide. Published messages may or may not be persistent, depending on the implementation. In distributed publish/subscribe such as MANETs, it is generally not expected that publishers would persist and deliver messages at a later time via brokers\cite{psfaces}, although some implementations exist\cite{reds}. Managing an overlay network of brokers adds considerable complexity.

STEAM (Scalable Timed Events and Mobility)\cite{steam} is an example of an event-based middleware which uses publish/subscribe for communication. REDS (REconfigurable Dispatching System) is a framework for building publish/subscribe systems in highly dynamic networks.

\subsection{Remote Procedure Call}

Remote procedure call (RPC) is a form of message passing in which remote procedures or method invocations are syntactically similar or identical to local function calls, but the code is actually executed on a remote machine. When the procedure is called, arguments are copied to the remote machine, which executes the requested method and sends the resulting value back to the local machine. RPC is temporally coupled, since remote methods must be available at the time of the call. However, RPC is referentially decoupled, since the application does not know which node it is communicating with, only that it supports a given method.

A host can ``export" an object to be accessed remotely. Remote hosts discover these remote objects by name or type and then invoke methods defined on the object. RPC is spatially coupled, since the remote object must be available in order to invoke the method. Arguments may be passed to the remote method and the return value of the method is returned to the local process. Since RPC implies code execution, failures during the remote calls can be dangerous\cite{distbook}.

Group RPC invokes the same method with the same arguments on all matching remote objects. In a MANET, group RPC must be performed asynchronously to be practical: the call may return multiple values but the client cannot rely on all remote hosts returning a value successfully. A timeout could be used instead, but a short timeout would cause unnecessarily lost messages, while a long timeout could cause long delays in the execution of the application.

RPC inherently supports one-to-one two-way communication. Arguments to a method can be considered sending a message, and the return value of the method can be thought of as sending a reply message. RPC can also support group communication by invoking a given method on multiple remote hosts.

Many-to-Many Invocation (M2MI)\cite{m2mi} is an RPC implementation for MANETs which avoids costly ad hoc routing and discovery by broadcasting messages. Messages are addressed by object type, so if a device hosts an object of the addressed type, it will pass the message to that object.

The advantage of M2MI is simplicity. As messages are simply broadcast without expectation of reply, there is no need to worry about return values or blocking while waiting for confirmation. At the language level, there is no difference on the sender's side between a message which is actually received and one which is not received by anyone. Though this provides simplicity, it also means more work for the programmer. As there is no guarantee of message delivery, any functionality beyond simple unidirectional message passing must be implemented on top of M2MI.

AmbientTalk\cite{ambienttalk} is a complete object oriented language inspired in part by M2MI's message passing. AmbientTalk implements a higher level abstraction of resource discovery and disconnection handling which is absent from M2MI, but retains the idea of object handles and remote method invocations. All remote events are handled asynchronously by AmbientTalk through the registration of callbacks. A block of code may be registered to be invoked when discovering a certain resource type. AmbientTalk also adds the ability to receive values from method invocations on remote objects through the use of futures. By default, messages sent to remote objects are buffered until they can be sent. The programmer can also choose to break the connection and recall buffered messages.

\subsection{Tuple Spaces}

\textit{Tuple spaces}, introduced in the Linda\cite{linda} coordination language, operate on a distributed shared memory space of typed, ordered tuples. Tuples are sent using the \textbf{out} operation then retrieved by matching templates with \textbf{rd}, which copies the tuple, or \textbf{in}, which atomically removes the tuple from the tuple space. If multiple tuples match, one is chosen nondeterministically. Tuple spaces have strict semantics for \textbf{rd} and \textbf{in}: if a matching tuple exists, it \textit{must} be returned. \textbf{rd} and \textbf{in} are blocking operations, but typically non-blocking versions are provided called \textit{inp()} and \textit{rdp()} which return immediately even if there are no matching tuples.

Tuple spaces are both temporally and referentially decoupled. Tuples may be read any time after they have been written to the tuple space, provided they have not been removed in the meantime. Where a tuple may physically reside is completely unknown to the application; all communication is performed by requesting a tuple matching a particular template. Tuple spaces easily support group communication, since a single tuple may be read by any number of nodes. One-to-one communication can be achieved by agreement on a particular tuple field, although this does not guarantee unintended receivers will not read or even remove the tuple.

An issue particular to tuple spaces is the ``multiple read problem": nondestructively retrieving all matching tuples requires repeated \textbf{rd} operations, which may return any matching tuple\cite{mrdp}. One solution is to use a mutex tuple to gain exclusive access to the tuple space, remove all matching tuples using \textbf{in}, replace the tuples, and then release the mutex. However, this approach prevents concurrent access and is dangerous in MANETs where the node with the mutex may disappear. Another solution uses a counter in each tuple. The application reads tuple 1, then tuple 2, etc., in order. Not only does this introduce performance issues (if a particular tuple is unavailable, for example, the application must wait on it), but if multiple processes are producing tuples they must coordinate to generate consistent counters, essentially requiring another global mutex.

Yet another option, proposed in \cite{edwards2001jini}, relies on being able to use transactions over the tuple spaces. Instead of using \textbf{rd}, the application uses \textbf{in} inside a transaction to retrieve all desired tuples, then cancels the transaction to replace all of the tuples back into the tuple space. This causes the tuples to be unavailable during the transaction and requires support for transactions, which does not seem common. A final option, proposed in \cite{mrdp}, is to simply introduce a new \textbf{copy-collect} operation which copies all matching tuples. We will find in Section \ref{sec:wb} that even this is not sufficient for typical needs of an application.

Several projects have adapted tuple spaces to MANETs, including L$^{2}$imbo\cite{limbo}, LIME\cite{lime}, TOTAM\cite{totam}, and EgoSpaces\cite{egospaces}. LIME (Linda in mobile environment) is a well-established implementation of tuple spaces\cite{linda} for mobile environments. Each device or agent has its own tuple space, which can merge with remote tuple spaces when they come into range of each other. Tuples can be read and written from specific locations, but can also be read or written to the ``federated" tuple space which includes the local tuple space and any tuple spaces which are currently merged with it. However, the tuple will reside in a particular tuple space, so when that device or agent moves away, the tuples in that tuple space will move with it and be out of reach. LIME requires tuple spaces joining or leaving the federation do so explicitly, which is clearly at odds with the dynamicity of MANETs where disconnections may occur unexpectedly.

Besides the typical tuple space operations, LIME also provides \textit{reactions} which can be triggered when a matching tuple is added to the tuple space. Reactions allow asynchronous and push-based communication when tuple spaces are typically synchronous and pull-based. The implementation of reactions registers hooks on each remote host. When a new tuple is stored, the hooks are evaluated first to see if any match the tuple. For those that do, the registering host is notified and a copy of the tuple is transferred.

Note that \textit{all} reactions must complete before any other actions may occur. This includes a tuple space leaving the tuple space federation. As discussed in \cite{limerevisted}, this requirement can lead to livelocks were a node is not ``allowed" to leave the federation due to mutually recursive reactions. LIME II\cite{lime2}, Limone\cite{limone}, and CoreLIME\cite{corelime} are proposed to meet shortcomings in LIME.

MESH\textit{Mdl}~\cite{meshmdl}  is another tuple space implementation, but varies slightly from the LIME model. In MESH\textit{Mdl}, there is a single tuple space shared between all applications on a device. All communication between applications is performed via  this shared tuple space. Remote tuple spaces are not shared like in LIME, but are accessible for reads and writes only: it is not possible to remove tuples from a remote tuple space. MESH\textit{Mdl} supports mobile agents and recommends using them if actions need to be performed on a remote tuple space. MESH\textit{Mdl} also adds the idea of being able to automatically write, read, or block tuples from other tuple spaces.

Tuples on the Air (TOTA)~\cite{tota} also implements a tuple space for MANETs, but differs from LIME and MESH\textit{Mdl}. Rather than storing tuples on a particular device, tuples in TOTA are propagated through the network according to rules specified per tuple. As the tuples move through the network, they can acquire context information about the network, such as how many hops they have traveled from the source.

\subsection{Mobile Agents}

Using mobile agents in MANETs allows programs to move code to data, rather than communicating the data to the running program. Code migrates to where data or resources are located, executes at that location, and then returns to its original location to report the results. This allows mobile devices, which usually have little processing power, to offload computationally intensive work to machines with more processing and power resources.

SpatialViews\cite{sv} is a language extension to Java ME which allows programs to iterate over groups of devices. The code inside the loop is executed on the initial device and then migrates to the next, eventually making its way back to the initial node. This allows for complex operations to be written easily, as the language has built-in support for such things actions as reduction operations. The iteration itself is generally done according to some physical layout, although it is possible to iterate over all objects or to use logical locations instead.
